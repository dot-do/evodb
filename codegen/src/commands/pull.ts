/**
 * @evodb/codegen Pull Command
 *
 * Generates TypeScript type definitions from database schemas.
 * Output: .evodb/[db].d.ts and .evodb/index.d.ts
 */

import { existsSync, mkdirSync, writeFileSync, readdirSync } from 'node:fs';
import { join } from 'node:path';
import type {
  PullOptions,
  PullResult,
  Schema,
  ColumnDefinition,
  SqlType,
} from '../types.js';

// Re-export types for external use
export type { PullOptions, PullResult };

/**
 * Map SQL types to TypeScript types
 */
function sqlTypeToTs(sqlType: SqlType): string {
  switch (sqlType) {
    case 'integer':
      return 'number';
    case 'text':
      return 'string';
    case 'real':
      return 'number';
    case 'blob':
      return 'Uint8Array';
    case 'boolean':
      return 'boolean';
    case 'json':
      return 'unknown';
    case 'timestamp':
      return 'Date';
    default:
      return 'unknown';
  }
}

/**
 * Convert snake_case to PascalCase for interface names
 */
function toPascalCase(str: string): string {
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Generate TypeScript interface for a table
 */
function generateTableInterface(
  tableName: string,
  columns: Record<string, ColumnDefinition>
): string {
  const interfaceName = toPascalCase(tableName);
  const lines: string[] = [];

  lines.push(`export interface ${interfaceName} {`);

  for (const [columnName, column] of Object.entries(columns)) {
    const tsType = sqlTypeToTs(column.type);
    const nullable = column.nullable === true;
    const typeAnnotation = nullable ? `${tsType} | null` : tsType;
    lines.push(`  ${columnName}: ${typeAnnotation};`);
  }

  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate TypeScript definitions for a database schema
 */
function generateTypeDefs(schema: Schema, dbName: string): string {
  const lines: string[] = [];

  lines.push(`/**`);
  lines.push(` * Auto-generated type definitions for database: ${dbName}`);
  lines.push(` * Generated by @evodb/codegen`);
  lines.push(` * DO NOT EDIT MANUALLY`);
  lines.push(` */`);
  lines.push('');

  for (const [tableName, table] of Object.entries(schema.tables)) {
    lines.push(generateTableInterface(tableName, table.columns));
    lines.push('');
  }

  // Generate a database namespace with all tables
  const dbInterfaceName = toPascalCase(dbName) + 'Database';
  lines.push(`export interface ${dbInterfaceName} {`);

  for (const tableName of Object.keys(schema.tables)) {
    const interfaceName = toPascalCase(tableName);
    lines.push(`  ${tableName}: ${interfaceName};`);
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Update the index.d.ts to re-export all database types
 */
function updateIndexFile(evodbDir: string): void {
  const files = readdirSync(evodbDir).filter(
    (f) => f.endsWith('.d.ts') && f !== 'index.d.ts'
  );

  const exports = files.map((f) => {
    const moduleName = f.replace('.d.ts', '');
    return `export * from './${moduleName}';`;
  });

  const content = [
    '/**',
    ' * Auto-generated index for @evodb/codegen type definitions',
    ' * DO NOT EDIT MANUALLY',
    ' */',
    '',
    ...exports,
    '',
  ].join('\n');

  writeFileSync(join(evodbDir, 'index.d.ts'), content);
}

/**
 * Pull command: Generate TypeScript definitions from schema
 */
export async function pullCommand(options: PullOptions): Promise<PullResult> {
  const { db, cwd, schema } = options;
  const evodbDir = join(cwd, '.evodb');
  const files: string[] = [];

  try {
    // Ensure .evodb directory exists
    if (!existsSync(evodbDir)) {
      mkdirSync(evodbDir, { recursive: true });
    }

    // Generate type definitions
    const typeDefs = generateTypeDefs(schema, db);
    const dtsPath = join(evodbDir, `${db}.d.ts`);
    writeFileSync(dtsPath, typeDefs);
    files.push(`.evodb/${db}.d.ts`);

    // Update index.d.ts
    updateIndexFile(evodbDir);
    files.push('.evodb/index.d.ts');

    return {
      success: true,
      files,
    };
  } catch (error) {
    return {
      success: false,
      files,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
