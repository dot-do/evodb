/**
 * EvoDB TypeScript Type Generator
 * Generates TypeScript interfaces from EvoDB schema definitions
 */

import type { Schema, SchemaColumn, ColumnType } from '../../lakehouse/src/types';

/**
 * Options for type generation
 */
export interface GenerateOptions {
  /** Name for the root interface (default: "Root") */
  rootName?: string;
}

/**
 * Path tree node for reconstructing nested structures from flat paths
 */
export interface PathNode {
  /** Child nodes keyed by property name */
  children: Record<string, PathNode>;
  /** The schema column at this node (if it's a leaf) */
  column?: SchemaColumn;
  /** Whether this node represents an array */
  isArray: boolean;
  /** Element type for simple arrays (like tags[0] -> string) */
  elementType?: ColumnType;
}

/**
 * Convert a ColumnType to its TypeScript representation
 */
export function typeToTypeScript(type: ColumnType): string {
  // Handle string literal types
  if (typeof type === 'string') {
    switch (type) {
      case 'null':
        return 'null';
      case 'boolean':
        return 'boolean';
      case 'int32':
      case 'float64':
        return 'number';
      case 'int64':
        return 'bigint';
      case 'string':
        return 'string';
      case 'binary':
        return 'Uint8Array';
      case 'timestamp':
        return 'Date';
      case 'date':
      case 'uuid':
        return 'string';
      case 'json':
        return 'unknown';
      default:
        return 'unknown';
    }
  }

  // Handle complex types
  if (type.type === 'array') {
    return `${typeToTypeScript(type.elementType)}[]`;
  }

  if (type.type === 'map') {
    return `Record<${typeToTypeScript(type.keyType)}, ${typeToTypeScript(type.valueType)}>`;
  }

  if (type.type === 'struct') {
    const fields = type.fields
      .map((field) => {
        const tsType = typeToTypeScript(field.type);
        const nullableSuffix = field.nullable ? ' | null' : '';
        return `${field.name}: ${tsType}${nullableSuffix}`;
      })
      .join('; ');
    return `{ ${fields} }`;
  }

  return 'unknown';
}

/**
 * Build a path tree from flat column paths
 * Converts paths like "user.profile.name" into nested structures
 */
export function buildPathTree(columns: SchemaColumn[]): PathNode {
  const root: PathNode = {
    children: {},
    isArray: false,
  };

  for (const column of columns) {
    const path = column.name;
    // Parse the path into segments, handling array indices
    const segments = parsePath(path);

    let current = root;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const isLast = i === segments.length - 1;

      if (segment.isArrayIndex) {
        // Mark the parent node as an array
        // The array index itself doesn't create a new child
        current.isArray = true;
        if (isLast) {
          // Simple array like tags[0] -> tags: string[]
          current.elementType = column.type;
        }
        continue;
      }

      if (!current.children[segment.name]) {
        current.children[segment.name] = {
          children: {},
          isArray: false,
        };
      }

      current = current.children[segment.name];

      if (isLast) {
        current.column = column;
      }
    }
  }

  return root;
}

/**
 * Parse a path string into segments
 */
interface PathSegment {
  name: string;
  isArrayIndex: boolean;
}

function parsePath(path: string): PathSegment[] {
  const segments: PathSegment[] = [];
  let current = '';

  for (let i = 0; i < path.length; i++) {
    const char = path[i];

    if (char === '.') {
      if (current) {
        segments.push({ name: current, isArrayIndex: false });
        current = '';
      }
    } else if (char === '[') {
      if (current) {
        segments.push({ name: current, isArrayIndex: false });
        current = '';
      }
      // Find the closing bracket
      const closeBracket = path.indexOf(']', i);
      if (closeBracket !== -1) {
        segments.push({ name: path.slice(i + 1, closeBracket), isArrayIndex: true });
        i = closeBracket;
      }
    } else {
      current += char;
    }
  }

  if (current) {
    segments.push({ name: current, isArrayIndex: false });
  }

  return segments;
}

/**
 * Generate TypeScript types from a schema
 */
export function generateTypes(schema: Schema, options: GenerateOptions = {}): string {
  const rootName = options.rootName ?? 'Root';
  const tree = buildPathTree(schema.columns);

  const interfaces: string[] = [];
  generateInterface(tree, rootName, interfaces);

  const header = '// Auto-generated by evodb pull - DO NOT EDIT\n';
  return header + interfaces.join('\n');
}

/**
 * Generate an interface from a path tree node
 */
function generateInterface(
  node: PathNode,
  name: string,
  interfaces: string[],
  parentPath: string = ''
): void {
  const lines: string[] = [];
  lines.push(`export interface ${name} {`);

  const childNames = Object.keys(node.children).sort();

  for (const childName of childNames) {
    const child = node.children[childName];
    const interfaceName = parentPath ? `${parentPath}${capitalize(childName)}` : `${name}${capitalize(childName)}`;

    if (child.column && Object.keys(child.children).length === 0) {
      // Leaf node with a column
      const tsType = typeToTypeScript(child.column.type);
      // Don't add | null if the type is already null
      const needsNullable = child.column.nullable && tsType !== 'null';
      const nullableSuffix = needsNullable ? ' | null' : '';
      lines.push(`  ${childName}: ${tsType}${nullableSuffix};`);
    } else if (child.isArray && Object.keys(child.children).length === 0) {
      // Simple array (like tags[0] -> tags: string[])
      if (child.elementType) {
        const elementTs = typeToTypeScript(child.elementType);
        lines.push(`  ${childName}: ${elementTs}[];`);
      } else {
        lines.push(`  ${childName}: unknown[];`);
      }
    } else if (child.isArray) {
      // Array of objects
      const singularName = singularize(interfaceName);
      lines.push(`  ${childName}: ${singularName}[];`);
      generateInterface(child, singularName, interfaces, interfaceName);
    } else {
      // Nested object
      lines.push(`  ${childName}: ${interfaceName};`);
      generateInterface(child, interfaceName, interfaces, interfaceName);
    }
  }

  lines.push('}');
  interfaces.push(lines.join('\n'));
}

/**
 * Capitalize the first letter of a string
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Simple singularization (remove trailing 's' or 'es')
 */
function singularize(str: string): string {
  if (str.endsWith('ies')) {
    return str.slice(0, -3) + 'y';
  }
  if (str.endsWith('es')) {
    return str.slice(0, -2);
  }
  if (str.endsWith('s') && !str.endsWith('ss')) {
    return str.slice(0, -1);
  }
  return str + 'Item';
}
